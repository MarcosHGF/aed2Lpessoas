#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct noLista
{
    struct noLista *ant;
    char   dado[10];
    struct noLista *prox;
};

struct noArvore
{
    struct noArvore *esq;
    char   dado[10];
    struct noArvore *dir;
};

typedef struct noArvore *arvore;

typedef struct
{
    struct noLista *inicio;
    struct noLista *fim;
} listacircularde;

void cria(listacircularde *q);
int  insereOrdenado(listacircularde *q, char d[10]);
void mostra(listacircularde q, int sentido);

void insere(arvore *t, char d[10]);
void inOrdem(arvore t);
void preOrdem(arvore t);
void posOrdem(arvore t);

main()
{
    listacircularde lista;
    arvore tree = NULL;

    cria(&lista);

    printf("Inserindo dados na lista com ordenacao...\n");
    insereOrdenado(&lista,"Maria");
    insereOrdenado(&lista,"Ana");
    insereOrdenado(&lista,"Beatriz");
    insereOrdenado(&lista,"Zilda");
    insereOrdenado(&lista,"Luisa");
    insereOrdenado(&lista,"Fernanda");
    insereOrdenado(&lista,"Manuela");
    insereOrdenado(&lista,"Heloisa");

    printf("\nApresentando a lista do inicio para o fim...\n");
    mostra(lista,0);
    printf("\nApresentando a lista do fim para o inicio...\n");
    mostra(lista,1);

    // A implementacao da solucao deve comecar aqui...
    struct noLista *Marcosaux;
    Marcosaux = lista.inicio;
    do{
            insere(&tree, Marcosaux->dado);
            printf("nome: %s, ", Marcosaux->dado);
            Marcosaux = Marcosaux->prox;
        } while (Marcosaux != lista.inicio);

    printf("\nPRE-ORDEM\n");
    preOrdem(tree);
    printf("\nIN-ORDEM\n");
    inOrdem(tree);
    printf("\nPOS-ORDEM\n");
    posOrdem(tree);
}

void cria(listacircularde *q)
{
    q->inicio = NULL;
    q->fim = NULL;
}

int  insereOrdenado(listacircularde *q, char d[30])
{
    struct noLista *aux, *anterior, *atual;
    aux = (struct noLista*) malloc(sizeof(struct noLista));
    if (aux == NULL)
        return 0;

    // Lista vazia, portanto insere o primeiro n�
    if (q->inicio == NULL)
    {
        strcpy(aux->dado, d);
        q->inicio = aux;
        q->fim = aux;
        aux->prox = q->inicio;
        aux->ant = q->fim;
        return 1;
    }

    // Lista n�o vazia, inser��o de um novo in�cio
    if (strcmp(d, q->inicio->dado) < 0)
    {
        strcpy(aux->dado, d);
        aux->prox = q->inicio;
        q->inicio->ant = aux;
        q->inicio = aux;
        q->fim->prox = aux;
        aux->ant = q->fim;
        return 1;
    }

    // Lista n�o vazia, inser��o no final
    if (strcmp(d, q->fim->dado) > 0)
    {
        strcpy(aux->dado, d);
        q->fim->prox = aux;
        aux->ant = q->fim;
        aux->prox = q->inicio;
        q->fim = aux;
        q->inicio->ant = q->fim;
        return 1;
    }

    // Lista n�o vazia, inser��o no meio
    anterior = q->inicio;
    atual = q->inicio->prox;
    while (strcmp(d, atual->dado) > 0)
    {
        anterior = atual;
        atual = atual->prox;
    }

    strcpy(aux->dado, d);
    aux->prox = atual;
    aux->ant = anterior;
    anterior->prox = aux;
    atual->ant = aux;
    return 1;
}

void mostra(listacircularde q, int sentido)
{
    struct noLista *aux;

    if (sentido == 0)
    {
        aux = q.inicio;
        do
        {
            printf("%s\n", aux->dado);
            aux = aux->prox;
        } while (aux != q.inicio);
    }

    if (sentido == 1)
    {
        aux = q.fim;
        do
        {
            printf("%s\n",aux->dado);
            aux = aux->ant;
        } while (aux != q.fim);
    }
}

void insere(arvore *t, char d[10])
{
    if (*t == NULL)
    {
        *t = (struct noArvore*) malloc(sizeof(struct noArvore));
        if (*t != NULL)
        {
            (*t)->esq = NULL;
            (*t)->dir = NULL;
            strcpy((*t)->dado, d);
        }
        else
            printf("Memoria insuficiente");
    }
    else
        if (strcmp(d,(*t)->dado) < 0)
            insere(&(*t)->esq, d);
        else
            if (strcmp(d, (*t)->dado) > 0)
                insere(&(*t)->dir, d);
            else
                printf("Duplica��o de no");
}

void preOrdem(arvore t)
{
    if (t != NULL)
    {
        printf("%s ", t->dado);
        preOrdem(t->esq);
        preOrdem(t->dir);
    }
    else
        printf("NULL ");
}

void inOrdem(arvore t)
{
    if (t != NULL)
    {
        inOrdem(t->esq);
        printf("%s ", t->dado);
        inOrdem(t->dir);
    }
    else
        printf("NULL ");
}

void posOrdem(arvore t)
{
    if (t != NULL)
    {
        posOrdem(t->esq);
        posOrdem(t->dir);
        printf("%s ", t->dado);
    }
    else
        printf("NULL ");
}

//by prof.João Benedito
